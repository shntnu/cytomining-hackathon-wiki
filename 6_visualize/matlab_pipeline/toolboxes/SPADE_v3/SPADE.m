function varargout = SPADE(varargin)
% SPADE M-file for SPADE.fig
%      SPADE, by itself, creates a new SPADE or raises the existing
%      singleton*.
%
%      H = SPADE returns the handle to a new SPADE or the handle to
%      the existing singleton*.
%
%      SPADE('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in SPADE.M with the given input arguments.
%
%      SPADE('Property','Value',...) creates a new SPADE or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before SPADE_OpeningFunction gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to SPADE_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to help SPADE

% Last Modified by GUIDE v2.5 16-May-2011 11:14:08

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @SPADE_OpeningFcn, ...
                   'gui_OutputFcn',  @SPADE_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


% --- Executes just before SPADE is made visible.
function SPADE_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to SPADE (see VARARGIN)

% Choose default command line output for SPADE
handles.output = hObject;
handles.directoryname = '';
handles.file_annot = cell(0);
handles.all_fcs_filenames = cell(0);
handles.all_markers = cell(0);
handles.all_overlapping_markers = cell(0);
handles.used_markers = cell(0);
handles.used_files = cell(0);
handles.apply_compensation = 0;
handles.transformation_option = 1; % 0 means no transformation, 1 means arcsinh, 2 means arcsinh followed by 0-mean 1-var
handles.arcsinh_cofactor = 5;
handles.kernel_width_factor = 5;
handles.density_estimation_optimization_factor = 1.5;
handles.outlier_density = 1;
handles.target_density_mode = 2; % 1 means using target density percentile, 2 means choose a TD such that a fixed number of cells survive downsampling
handles.target_density = 3;
handles.target_cell_number = 20000;
handles.max_allowable_events = 50000;
handles.number_of_desired_clusters = 100;
handles.clustering_algorithm = 'kmeans'; % possible choices are 'kmenas', 'agglomerative'
handles.file_used_to_build_SPADE_tree = cell(0);
% temp file names that are generated by SPADE software to store intermediate and final results
handles.parameter_filename = 'SPADE_parameters.mat';
handles.pooled_downsampled_filename = 'SPADE_pooled_downsampled_data.mat';
handles.cluster_mst_upsample_filename='SPADE_cluster_mst_upsample_result.mat';
% % Update handles structure
guidata(hObject, handles);
% check the c components, if not properly compiled, recompile it
check_compile_c_components



% UIWAIT makes SPADE wait for user response (see UIRESUME)
% uiwait(handles.figure1);


% --- Outputs from this function are returned to the command line.
function varargout = SPADE_OutputFcn(hObject, eventdata, handles) 
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% browse and select working directory
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% stop user from editing the working directory manually
function edit_working_directory_Callback(hObject, eventdata, handles)
set(handles.edit_working_directory,'String',handles.directoryname);

% --- Executes during object creation, after setting all properties.
function edit_working_directory_CreateFcn(hObject, eventdata, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

% --- Executes on button press in button_browse_directory.
function button_browse_directory_Callback(hObject, eventdata, handles)
% hObject    handle to button_browse_directory (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
directoryname = uigetdir('', 'Select working directory');
% check whether this button needs to do anything.
if length(directoryname)==0 || isequal(directoryname,0) % the user may click cancel in the selection dialog box
    fprintf('No working directory is selected!!\n\n');
    if isempty(handles.directoryname)
        fprintf('Current director is empty.\n\n');
    else
        fprintf('Current director is: %s\n\n',handles.directoryname);
    end
    return
end
if exist(directoryname)~=7
    fprintf('The selected directory is somehow not a valid directory\nThis probably will never happen\if this happens, needs some debugging here\n\n');
    return
end

% initialize analysis of this directory
handles.directoryname = directoryname;
set(handles.edit_working_directory,'String',directoryname);
all_fcs_filenames = getfilenames(handles.directoryname);
all_fcs_filenames = all_fcs_filenames(isInListEnd(all_fcs_filenames,'.fcs'));
if length(all_fcs_filenames)==0 % if this is a valid directory, but has no fcs file in it
    % ??? clear all internal variables
    fprintf('There are %d fcs files in this directory!\n\n',length(all_fcs_filenames));
    handles.all_fcs_filenames = cell(0);
    handles.file_annot = cell(0); 
    handles.all_markers = cell(0);
    handles.all_overlapping_markers = cell(0);
    handles.used_markers = cell(0);
    handles.used_files = cell(0);
    handles.file_used_to_build_SPADE_tree = cell(0);
    guidata(hObject, handles);
    return
end

% if isequal(handles.all_fcs_filenames,all_fcs_filenames) % if the user already switched to this directory, but accidentally clicked this browse button again
%     return % do nothing
% end
handles.all_fcs_filenames = all_fcs_filenames;

parameter_filename = fullfile(handles.directoryname,handles.parameter_filename);
if exist(parameter_filename)==2  % if exist a SPADE parameter file, 
    load(parameter_filename, 'all_fcs_filenames');
    if ~isequal(handles.all_fcs_filenames,all_fcs_filenames) % if all_fcs_filenames not match, clear this file
        delete(parameter_filename);
    end        
end

if exist(parameter_filename)==2 % if a SPADE parameter file and it passed the above check (all_fcs_filenames match)
    % load parameters from the SPADE parameter file
    load(parameter_filename,'all_fcs_filenames','file_annot','all_markers','all_overlapping_markers', ...
        'used_markers', 'apply_compensation', 'transformation_option', 'arcsinh_cofactor', 'kernel_width_factor', ...
        'density_estimation_optimization_factor', 'outlier_density', 'target_density_mode', 'target_density',...
        'target_cell_number', 'max_allowable_events', 'number_of_desired_clusters', 'file_used_to_build_SPADE_tree','clustering_algorithm');
    handles.all_fcs_filenames = all_fcs_filenames;
    handles.file_annot = file_annot;
    handles.all_markers = all_markers;
    handles.all_overlapping_markers = all_overlapping_markers;
    handles.used_markers = used_markers;
    if exist('apply_compensation')
        handles.apply_compensation = apply_compensation;
    else
        handles.apply_compensation = 0;
    end
    handles.transformation_option = transformation_option; % 0 means no transformation, 1 means arcsinh, 2 means arcsinh followed by 0-mean 1-var
    handles.arcsinh_cofactor = arcsinh_cofactor;
    handles.kernel_width_factor = kernel_width_factor;
    handles.density_estimation_optimization_factor = density_estimation_optimization_factor;
    handles.outlier_density = outlier_density;
    handles.target_density_mode = target_density_mode; % 1 means using target density percentile, 2 means choose a TD such that a fixed number of cells survive downsampling
    handles.target_density = target_density;
    handles.target_cell_number = target_cell_number;
    handles.max_allowable_events = max_allowable_events;
    handles.number_of_desired_clusters = number_of_desired_clusters;
    handles.file_used_to_build_SPADE_tree = file_used_to_build_SPADE_tree;
    if ~exist('clustering_algorithm')
        handles.clustering_algorithm = 'agglomerative';  % option of clusteirng algorithm is a new update, older analysis are all agglomerative, that's why we set it to be agglomerative if an analysis does not specify the algorithm. In all new analysis, the algorithm option is always specified. 
        clustering_algorithm = handles.clustering_algorithm;
        save(parameter_filename,'clustering_algorithm','-append');
    else
        handles.clustering_algorithm = clustering_algorithm;
    end
    
    
else % if there does not exist a result file,  
    handles.all_fcs_filenames = all_fcs_filenames;
    handles.file_annot = all_fcs_filenames; % make sure that all_fcs_filenames and file_annot are of the same dimension
    % for i=1:length(handles.all_fcs_filenames)
    %     handles.file_annot{i} = ['File',num2str(i,'%04d')]; % this line assumes that the total number of fcs files <100, which is reasonable 
    % end
    handles.all_markers = cell(0);
    handles.all_overlapping_markers = cell(0);
    handles.used_markers = cell(0);
    handles.used_files = cell(0);
    handles.apply_compensation = 0;
    handles.transformation_option = 1; % 0 means no transformation, 1 means arcsinh, 2 means arcsinh followed by 0-mean 1-var
    handles.arcsinh_cofactor = 5;
    handles.kernel_width_factor = 5;
    handles.density_estimation_optimization_factor = 1.5;
    handles.outlier_density = 1;
    handles.target_density_mode = 2; % 1 means using target density percentile, 2 means choose a TD such that a fixed number of cells survive downsampling
    handles.target_density = 3;
    handles.target_cell_number = 20000;
    handles.max_allowable_events = 50000;
    handles.number_of_desired_clusters = 100;
    handles.clustering_algorithm = 'kmeans'; % possible choices are 'kmenas', 'agglomerative'
    handles.file_used_to_build_SPADE_tree = cell(0);
    handles.tmpDataForClustering_filename = [];
    handles.tmpResultsClusteringMST_filename=[];
        
    file_annot = handles.file_annot;
    all_markers = handles.all_markers;
    all_overlapping_markers = handles.all_overlapping_markers;
    used_markers = handles.used_markers;
    apply_compensation = handles.apply_compensation;
    transformation_option = handles.transformation_option;
    arcsinh_cofactor = handles.arcsinh_cofactor;
    kernel_width_factor = handles.kernel_width_factor;
    density_estimation_optimization_factor = handles.density_estimation_optimization_factor;
    outlier_density = handles.outlier_density;
    target_density_mode = handles.target_density_mode;
    target_density = handles.target_density;
    target_cell_number = handles.target_cell_number;
    max_allowable_events = handles.max_allowable_events;
    number_of_desired_clusters = handles.number_of_desired_clusters;
    clustering_algorithm = handles.clustering_algorithm;
    file_used_to_build_SPADE_tree = handles.file_used_to_build_SPADE_tree;
    save(parameter_filename,'all_fcs_filenames','file_annot','all_markers','all_overlapping_markers', ...
        'used_markers', 'apply_compensation', 'transformation_option', 'arcsinh_cofactor', 'kernel_width_factor', ...
        'density_estimation_optimization_factor', 'outlier_density', 'target_density_mode', 'target_density',...
        'target_cell_number', 'max_allowable_events', 'number_of_desired_clusters', 'file_used_to_build_SPADE_tree','clustering_algorithm');
end
guidata(hObject, handles);
View_Edit_file_annotations(handles.all_fcs_filenames,handles.file_annot,handles);





% --- Executes on button press in button_View_Edit_file_annotations.
function button_View_Edit_file_annotations_Callback(hObject, eventdata, handles)
% hObject    handle to button_View_Edit_file_annotations (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
directoryname = handles.directoryname;
% check whether this button needs to do anything.
if length(handles.directoryname)==0 
    fprintf('No working directory is selected!!\n\n');
    return
end
if exist(handles.directoryname)~=7
    fprintf('The selected directory is somehow not a valid directory,\n maybe deleted by user while the SPADE GUI is running!\n\n');
    return
end
if length(handles.all_fcs_filenames)==0 
    fprintf('There are no fcs files in this directory!\n\n');
    return
end
if length(handles.all_fcs_filenames) ~= length(handles.file_annot)
    fprintf('Length of all_fcs_filenames and file_annot does not match!\nTerrible - this should not happen\n\n');
    return
end
% if isequal(directoryname,0) || isequal(directoryname,'')  % if this is not a valid directory, the user actually clicked cancel, we do nothing
%     return
% end


if exist(directoryname)==7 % it is a valid directory
    if length(handles.all_fcs_filenames)==0 
        fprintf('There are no fcs files in this directory!\n\n');
        return
    end
    if length(handles.all_fcs_filenames) ~= length(handles.file_annot)
        fprintf('Length of all_fcs_filenames and file_annot does not match!\nTerrible - this should not happen\n\n');
        return
    end
    if length(handles.all_fcs_filenames)~=0 && length(handles.all_fcs_filenames) == length(handles.file_annot)
        View_Edit_file_annotations(handles.all_fcs_filenames,handles.file_annot,handles);
    end
end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% parameter setup
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% --- Executes on button press in button_setup_parameters.
function button_setup_parameters_Callback(hObject, eventdata, handles)
% hObject    handle to button_setup_parameters (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% check whether this button needs to do anything.
if length(handles.directoryname)==0 
    fprintf('No working directory is selected!!\n\n');
    return
end
if exist(handles.directoryname)~=7
    fprintf('The selected directory is somehow not a valid directory,\n maybe deleted by user while the SPADE GUI is running!\n\n');
    return
end
if length(handles.all_fcs_filenames)==0 
    fprintf('There are no fcs files in this directory!\n\n');
    return
end
if length(handles.all_fcs_filenames) ~= length(handles.file_annot)
    fprintf('Length of all_fcs_filenames and file_annot does not match!\nTerrible - this should not happen\n\n');
    return
end


% if result file does not exist 
if isempty(handles.all_markers)
    handles.all_markers = cell(0);
    handles.all_overlapping_markers = cell(0);
    for i=1:length(handles.all_fcs_filenames)
        filename = fullfile(handles.directoryname,handles.all_fcs_filenames{i});
        [fcshdr] = readfcs_v2_only_header(filename);
        display(['Get marker names from fcs file:'])
        display(['   ',handles.all_fcs_filenames{i}]);
        marker_names=cell(0);
        for i=1:length(fcshdr.par), 
            marker_names{i,1} = fcshdr.par(i).name2;  
            if isequal(unique(fcshdr.par(i).name2),' ') || isempty(marker_names{i,1})
                marker_names{i,1} = fcshdr.par(i).name;  
            end
        end
        [C,I] = setdiff(marker_names, handles.all_markers);
        if ~isempty(I)
            handles.all_markers = [handles.all_markers;marker_names(sort(I))];
        end
        if length(handles.all_overlapping_markers)==0
            handles.all_overlapping_markers = marker_names;
        else
            [C,IA,IB] = intersect(handles.all_overlapping_markers, marker_names);
            handles.all_overlapping_markers = handles.all_overlapping_markers(sort(IA));
        end
    end
    handles.used_markers = cell(0);
    handles.file_used_to_build_SPADE_tree = handles.file_annot;
    
    parameter_filename = fullfile(handles.directoryname,handles.parameter_filename);
    all_markers = handles.all_markers;
    all_overlapping_markers = handles.all_overlapping_markers;
    used_markers = handles.used_markers;
    file_used_to_build_SPADE_tree = handles.file_used_to_build_SPADE_tree;
    save(parameter_filename,'all_markers','all_overlapping_markers', 'used_markers', 'file_used_to_build_SPADE_tree', '-append');
    
    
    
    guidata(hObject, handles);
end
View_Edit_SPADE_parameters(handles);


% --- Executes on button press in button_1_compute_local_density.
function button_1_compute_local_density_Callback(hObject, eventdata, handles)
% check whether this button needs to do anything.
if length(handles.directoryname)==0 
    fprintf('No working directory is selected!!\n\n');
    return
end
if exist(handles.directoryname)~=7
    fprintf('The selected directory is somehow not a valid directory,\n maybe deleted by user while the SPADE GUI is running!\n\n');
    return
end
if length(handles.all_fcs_filenames)==0 
    fprintf('There are no fcs files in this directory!\n\n');
    return
end
if length(handles.all_fcs_filenames) ~= length(handles.file_annot)
    fprintf('Length of all_fcs_filenames and file_annot does not match!\nTerrible - this should not happen\n\n');
    return
end
if isempty(handles.used_markers)
    fprintf('No markers selected to build the SPADE tree!\nPlease update algorithm parameters and select markers for tree construction!\n\n');
    return
end


local_density_available = 0;
for i=1:length(handles.all_fcs_filenames)
    fcs_filename = fullfile(handles.directoryname,handles.all_fcs_filenames{i});
    mat_filename = [fcs_filename(1:end-3),'mat'];
    if exist(mat_filename)==2 % if the .mat file that stores the downsampling info already exist
        local_density_available = local_density_available + 1;
    end
end
fprintf('There are %d fcs files in this directory, %d with local density computed already.\n\nStart to work on the remaining %d files ...\n', length(handles.all_fcs_filenames), local_density_available, length(handles.all_fcs_filenames)-local_density_available);


for i=1:length(handles.all_fcs_filenames)
    fcs_filename = fullfile(handles.directoryname,handles.all_fcs_filenames{i});
    mat_filename = [fcs_filename(1:end-3),'mat'];
    
    if exist(mat_filename)==2 % if the .mat file that stores the downsampling info already exist
        continue;
    end

    fprintf('Read fcs file %d/%d ... ',i,length(handles.all_fcs_filenames));
    fprintf('%s\n',handles.all_fcs_filenames{i});
%     [fcsdat, fcshdr, fcsdatscaled] = fca_readfcs(fcs_filename);
%     clear('fcsdatscaled');
%     for i=1:length(fcshdr.par), 
%         marker_names{i,1} = fcshdr.par(i).name2;  
%         if isequal(unique(fcshdr.par(i).name2),' ')
%             marker_names{i,1} = fcshdr.par(i).name;  
%         end
%     end
    if isequal(handles.apply_compensation,0) || ~isequal(handles.apply_compensation,1)
        [data, marker_names] = readfcs_v2(fcs_filename);
    else
        [data, marker_names, channel_names, scaled_data, compensated_data, fcshdr] = readfcs_v2(fcs_filename);
        data = compensated_data;
    end
    if ~exist(fullfile(handles.directoryname,'check_loaded_data'),'dir')
        mkdir(fullfile(handles.directoryname,'check_loaded_data'));
    end
    write_to_txt_v2(fullfile(handles.directoryname,'check_loaded_data',[handles.all_fcs_filenames{i}(1:end-3),'txt']), marker_names(:)', [], data(:,1:10)', char(9));
    fprintf('Number of events in this file %d\n', size(data,2));
    
    fprintf('Data transformation options in SPADE parameters ... ');
    switch handles.transformation_option
        case 0, 
            fprintf('No transofrmation performed\n');
%             data = fcsdat'; 
%             clear('fcsdat');
        case 1, 
            fprintf(['arcsinh transformation with cofactor ',num2str(handles.arcsinh_cofactor),'\n']);
            data = flow_arcsinh(data,handles.arcsinh_cofactor); 
%             data = flow_arcsinh(fcsdat',handles.arcsinh_cofactor); 
%             clear('fcsdat');
        case 2, display('2');
            fprintf(['arcsinh transformation with cofactor ',num2str(handles.arcsinh_cofactor),', followed by 0-mean-1-var normalization \n']);
            data = SPADE_per_gene_normalization(flow_arcsinh(data,handles.arcsinh_cofactor)); 
%             data = SPADE_per_gene_normalization(flow_arcsinh(fcsdat',handles.arcsinh_cofactor)); 
%             clear('fcsdat');
        otherwise, 1;
    end
    % data = data(:,1:min(end,500000)); %%NOTE: we don't want one single file to be super super huge, a single file normally does not get this big
        
    [C,IA,IB] = intersect(marker_names, handles.used_markers);
    used_markers = handles.used_markers;

    fprintf('Compute local density for each cell in this file\n')
    new_data = data(:,1:min(size(data,2),2000));  %% NOTE: this should be 2000, need to alter back later
    fprintf('  calculate median min dist ...')
    tic; [min_dist,NN_ind] = compute_min_dist_downsample(new_data(IA,:),data(IA,1:min(size(data,2),500000)));toc  % since new_data is part of data, this function does not compute min L1 dist. It computes the min non-zero distance, because there will be one 0. However, this creates a problem, what if the data simply contains a lot of identical entries, and result in multiple 0's? This code ignores them all, because this being zero does no good to the subsequent definination of neighborhood 
    median_min_dist = median(min_dist);
    kernel_width = median_min_dist*handles.kernel_width_factor;
    optimizaiton_para = median_min_dist*handles.density_estimation_optimization_factor;
    fprintf('  calculate local densities ...')
    tic; [local_density] = compute_local_density(data(IA,:), kernel_width, optimizaiton_para); toc

    save(mat_filename, 'data', 'marker_names', 'used_markers', 'local_density', 'kernel_width');

    clear( 'data', 'marker_names', 'used_markers', 'local_density', 'kernel_width');
end
fprintf('Done computing local density!\n\n');

    
    




% --- Executes on button press in button_2_pool_selected_files.
function button_2_pool_selected_files_Callback(hObject, eventdata, handles)
% check whether this button needs to do anything.
if length(handles.directoryname)==0 
    fprintf('No working directory is selected!!\n\n');
    return
end
if exist(handles.directoryname)~=7
    fprintf('The selected directory is somehow not a valid directory,\n maybe deleted by user while the SPADE GUI is running!\n\n');
    return
end
if length(handles.all_fcs_filenames)==0 
    fprintf('There are no fcs files in this directory!\n\n');
    return
end
if length(handles.all_fcs_filenames) ~= length(handles.file_annot)
    fprintf('Length of all_fcs_filenames and file_annot does not match!\nTerrible - this should not happen\n\n');
    return
end
% check if the local density info for all fcs files are available
for i=1:length(handles.all_fcs_filenames)
    % get file name
    fcs_filename = fullfile(handles.directoryname,handles.all_fcs_filenames{i});
    mat_filename = [fcs_filename(1:end-3),'mat'];
    if exist(mat_filename)~=2 % if the .mat file that stores the downsampling info already exist
        fprintf('Not all fcs files have local density calculated yet!!\nPlease click the Compute local densities button, and wait for it to finish before clicking this step.\n\n');
        return
    end
end

% gather the list of files used in  building SPADE tree
[c,used_file_ind,IB] = intersect(handles.file_annot,handles.file_used_to_build_SPADE_tree);
used_file_ind = sort(used_file_ind); 
% define variable for all pooled data
all_data=[];
tube_channel=[];
all_local_density=[];
for i=1:length(used_file_ind)
    % get file name
    fcs_filename = fullfile(handles.directoryname,handles.all_fcs_filenames{used_file_ind(i)});
    mat_filename = [fcs_filename(1:end-3),'mat'];
    % load file
    display(['downsampling and pooling fcs file: ',num2str(i),'/',num2str(length(used_file_ind))]);
    display(handles.all_fcs_filenames{used_file_ind(i)});
    load(mat_filename);
    % used to normalize the local densities for the other files 
    if i==1
        RefDataSize = size(data,2); % used to normalize the local densities for the other files 
        all_marker_names = marker_names;
        used_marker_names = used_markers;
    end
    % remove outliers
    if handles.outlier_density>0
        outlier_density = prctile(local_density,handles.outlier_density);
        data(:,local_density<=outlier_density)=[];
        local_density(local_density<=outlier_density)=[];
    end
    % compute target density
    switch handles.target_density_mode
        case 1
            target_density = prctile(local_density,handles.target_density);
        case 2
            num_desired_cells = handles.target_cell_number;
            target_density = downsample_to_certain_num_cells(data, local_density, num_desired_cells);
        otherwise
            1;
    end
    % % downsample
    % keep_prob = min(1,(target_density./local_density));
    % is_keep = rand(1,length(local_density))<keep_prob;  
    % is_keep(find(sum(isnan(data))~=0))=0;
    tic;
    is_keep = logical(deterministic_downsample_to_target_density(data(ismember(marker_names, used_markers),:), local_density, target_density));
    toc
    display([num2str(sum(is_keep)),' cells keeped in this fcs file'])
    display(' ');
    data = data(:,is_keep);
    local_density = local_density(is_keep)/length(is_keep)*RefDataSize;
    % pool data
    if isequal(marker_names,all_marker_names)
        all_data = [all_data,data];
    else
        new_marker_names = setdiff(marker_names,all_marker_names);
        all_marker_names = [all_marker_names;new_marker_names];
        all_data = [all_data;repmat(NaN,length(new_marker_names),size(all_data,2))];
        data_tmp = zeros(size(all_data,1),size(data,2))+NaN;
        [C,IA,IB] = intersect(marker_names,all_marker_names);
        data_tmp(IB,:) = data(IA,:);
        all_data = [all_data, data_tmp];
    end
    all_local_density = [all_local_density,local_density];
    tube_channel = [tube_channel,repmat(used_file_ind(i),1,size(data,2))];
end
all_data = [all_data;tube_channel];
all_marker_names{end+1} = 'FileInd';

data = all_data; 
marker_names = all_marker_names;
local_density = all_local_density;
display(['PooledDownsampledData has ', num2str(size(data,2)), ' cells from ', num2str(length(used_file_ind)), ' files']);
if size(data,2)>handles.max_allowable_events
    display(['Since the number of cells exceeds the max number of allowable events ', num2str(handles.max_allowable_events),', further deterministic downsampling is performed']);
    % % the following three lines are for uniform downsampling, which is from the implementation before
    % keep_ind = sort(randsample(1:size(data,2),handles.max_allowable_events));
    % data = data(:,keep_ind);
    % local_density = local_density(keep_ind);
    
    % for each file used to build the tree, compute NN distance
    possible_file_ind = unique(data(end,:));
    file_ind = data(end,:);
    IA = find(ismember(marker_names, used_markers));
    all_medians = [];
    fprintf('  calculate nearest neighbor dist for kernel width ... %4d / %4d',0,length(possible_file_ind));
    for i=possible_file_ind
        tmp = data(IA,file_ind==i);
        ns = createns(tmp','Distance','cityblock');
        [idx,dist] = knnsearch(ns,tmp','k',2);
        all_medians = [all_medians, median(dist(:,2))];
        fprintf('\b\b\b\b\b\b\b\b\b\b\b%4d / %4d',length(all_medians),length(possible_file_ind));
    end
    fprintf('\n');
    
    kernel_width = median(all_medians);
    optimizaiton_para = 0.01*kernel_width; 
    fprintf('  calculate local densities ...')
    tic; [local_density_tmp] = compute_local_density(data(IA,:), kernel_width, optimizaiton_para); toc

    num_desired_cells = handles.max_allowable_events;
    target_density = downsample_to_certain_num_cells(data, local_density_tmp, num_desired_cells);
    
    fprintf('  ');
    tic; 
    is_keep = logical(deterministic_downsample_to_target_density(data(IA,:), local_density_tmp, target_density));
    toc
    
    data = data(:,is_keep);
    local_density = local_density(:,is_keep);
    
    display(['Now, PooledDownsampledData has ', num2str(size(data,2)), ' cells from ', num2str(length(used_file_ind)), ' files']);
    display(' ');
end
save(fullfile(handles.directoryname, handles.pooled_downsampled_filename), 'all_data', 'all_local_density', 'data', 'local_density', 'marker_names', 'used_markers');
fprintf('Done!\n\n');
guidata(hObject, handles);






function target_density = downsample_to_certain_num_cells(data, local_density, desired_num)
% keep_prob = x./local_density
% need to find the value of "x", such that if we downsample according to
% "keep_prob", we end up with about "desired_num" cells
% therefore, need to solve the following
%      sum(min(x/local_density(i),1)) = desired_num
% which is equivalent to
%      x = (desired_num-i) / sum(1/local_density(i+1:end)) && local_density(i)<=x<=local_density(i+1) 

if desired_num>=length(local_density)
    target_density = max(local_density)+1;
    return
end
ld = [sort(local_density,'ascend')];
if desired_num/sum(1./local_density) <= ld(1)
    target_density = desired_num/sum(1./local_density);
    return
end
for i=1:length(ld)-1
    x = (desired_num-i) / sum(1./ld(i+1:end));
    if ld(i)<=x && x<=ld(i+1) 
        break;
    end
end
target_density = x;
return




% --- Executes on button press in button_3_clustering.
function button_3_clustering_Callback(hObject, eventdata, handles)
% check whether this button needs to do anything.
if length(handles.directoryname)==0 
    fprintf('No working directory is selected!!\n\n');
    return
end
if exist(handles.directoryname)~=7
    fprintf('The selected directory is somehow not a valid directory,\n maybe deleted by user while the SPADE GUI is running!\n\n');
    return
end
if length(handles.all_fcs_filenames)==0 
    fprintf('There are no fcs files in this directory!\n\n');
    return
end
if length(handles.all_fcs_filenames) ~= length(handles.file_annot)
    fprintf('Length of all_fcs_filenames and file_annot does not match!\nTerrible - this should not happen\n\n');
    return
end
% % check if the local density info for all fcs files are available
% for i=1:length(handles.all_fcs_filenames)
%     % get file name
%     fcs_filename = fullfile(handles.directoryname,handles.all_fcs_filenames{i});
%     mat_filename = [fcs_filename(1:end-3),'mat'];
%     if exist(mat_filename)~=2 % if the .mat file that stores the downsampling info already exist
%         fprintf('Not all fcs files have local density calculated yet!!\nPlease click the Compute local densities button, and wait for it to finish before clicking this step.\n\n');
%         return
%     end
% end
% % check if the pooled downsampled data file exists
if exist(fullfile(handles.directoryname, handles.pooled_downsampled_filename))~=2
    fprintf('The pooled downsampled data does not exist!\nPlease click the "Pool selected files" button before running this step!\n\n');
    return
end

% do the actual work here
load(fullfile(handles.directoryname, handles.pooled_downsampled_filename));
[C,IA,IB] = intersect(marker_names,used_markers); IA = sort(IA);
% % clustering and mst
switch handles.clustering_algorithm
    case 'kmeans'    
        % clustering and mst using kmeans
        fprintf('Working on clustering step...\n');
        if handles.number_of_desired_clusters==size(data(IA,:),2)
            centers = data(IA,:); idx = 1:size(data(IA,:),2); centers_ind = idx;
        else
            [idx,centers,centers_ind]=deterministic_kmeans_for_SPADE(data(IA,:)',handles.number_of_desired_clusters,local_density);
            % [idx, centers] = kmeans_phase1(data(IA,:)', handles.number_of_desired_clusters); 
            centers = centers'; idx = idx';
        end
        
%         center_dist_scaled = SPADE_center_pairwise_dist(idx,centers,centers_ind, data(IA,:), local_density);
%         [mst_tree,adj2] = mst_from_dist_matrix(center_dist_scaled);

        % [mst_tree,adj2] = SPADE_mst_from_contact_weights(idx,data(IA,:),local_density, data(end,:));
        [mst_tree,adj2] = SPADE_mst_from_contact_weights(idx,data(IA,:),local_density, ones(size(data(end,:))));
        fprintf('Done\n\n');
    case 'agglomerative'    
        % clustering and mst using agglomerative
        [mst_tree, idx, centers] = SPADE_cluster_cells(data(IA,:), handles.number_of_desired_clusters);
        data(:,idx==0)=[];
        local_density(idx==0)=[];
        idx(idx==0)=[];
    otherwise
        error('this should not happen!!')
end

% layout
disp('Working on visualization of the tree structure ... ');

% % node_positions = arch_layout(mst_tree);

% % A = mst_tree;
% % [X,spring,distance]=kamada_kawai_spring_layout_mex(...
% %     A, 1e-30, 20000, 1, ...  % adj, tolerance, max iteration, spring_constant
% %     [], 1, 0, 'matrix');     % progressive_opt, options.edge_length, edge_weights, edge_weight_opt;
% % node_positions = X';         % use spring embedding to determine node positoin

node_positions = radio_layout(mst_tree,centers);


% normalize node positions
node_positions = node_positions - repmat((max(node_positions,[],2)+min(node_positions,[],2))/2,1,size(node_positions,2));
node_positions = node_positions/max(abs(node_positions(:)))*50;
% rotate so that the highest density point is in the west
node_local_density = accumarray(idx', local_density')';
% weight_center = sum(node_positions.*repmat(node_local_density,2,1),2)/sum(node_local_density);
weight_center = find_highest_density_position(node_positions, node_local_density);
tmp_score = zeros(1,360) + Inf;
for i=1:360
    tmp_angle = i/180*pi;
    tmp = [cos(tmp_angle), sin(tmp_angle); -sin(tmp_angle), cos(tmp_angle)]*weight_center(:);
    if tmp(1)<0 
        tmp_score(i)=abs(tmp(2));
    end
end
[~,i] = min(tmp_score);
tmp_angle = i/180*pi;
node_positions = [cos(tmp_angle), sin(tmp_angle); -sin(tmp_angle), cos(tmp_angle)]*node_positions;
% flipup to make sure that more density is in the north half
if sum(node_local_density(node_positions(1,:)>0 & node_positions(2,:)>0)) < sum(node_local_density(node_positions(1,:)>0 & node_positions(2,:)<0))
    node_positions(2,:)=-node_positions(2,:);
end
fprintf('Done\n\n');
% [mst_tree,adj2] = mst(node_positions');


% determine initial node_size
node_size = zeros(1,size(node_positions,2));
for i=1:length(node_size), node_size(i) = sum(local_density(idx==i)); end
node_size = flow_arcsinh(node_size, median(node_size)/2);
node_size = ceil(node_size/max(node_size)*10);
node_size(node_size<5)=5;
node_size = node_size * 1.2;
% initialize annotations
tree_annotations = [];
tree_bubble_contour = [];
save(fullfile(handles.directoryname, handles.cluster_mst_upsample_filename), 'data', 'local_density', 'marker_names', 'used_markers','idx','mst_tree','node_positions','node_size','tree_annotations','tree_bubble_contour');

% upsample
all_clustered_data = data;
all_clustered_data_idx = idx;
[C,IA1,IB] = intersect(marker_names,used_markers);
for i=1:length(handles.all_fcs_filenames)
    indicator_of_this_file = all_clustered_data(end,:)==i;
    if sum(indicator_of_this_file)~=0
        clustered_data = all_clustered_data(:,indicator_of_this_file);
        clustered_data_idx = all_clustered_data_idx(indicator_of_this_file);
    else
        clustered_data = all_clustered_data;
        clustered_data_idx = all_clustered_data_idx;
    end
    
    % get file name
    fprintf('upsampling %d of %d files\n',i, length(handles.all_fcs_filenames));
    fcs_filename = fullfile(handles.directoryname,handles.all_fcs_filenames{i});
    mat_filename = [fcs_filename(1:end-3),'mat'];
    load(mat_filename,'data','marker_names');
    [C,IA2,IB] = intersect(marker_names,used_markers);

    %  tic;[min_dist,NN_index] = compute_min_dist_upsample(data(IA2,:),clustered_data(IA1,:));toc
    % % the following block replaces the above commented line, at least three times faster
    tic;
    NN_index = zeros(1,size(data,2));
    block_size = 1000;
    ns = createns(clustered_data(IA1,:)','nsmethod','kdtree','Distance','cityblock');
    fprintf('%3d%%',0);
    for k=1:block_size:size(data,2)
        ind_tmp = k:min([k+block_size-1,size(data,2)]);
        [a] = knnsearch(ns,data(IA2,ind_tmp)','k',1);
        NN_index(ind_tmp) = a';
        fprintf('\b\b\b\b%3d%%',round(max(ind_tmp)/size(data,2)*100));
    end    
    toc
    
    all_assign{i} = clustered_data_idx(NN_index);
end
all_fcs_filenames = handles.all_fcs_filenames;
file_annot = handles.file_annot;
handles.all_assign = all_assign;

% build the cell arrary that stores the average protein expression per node per marker per file
fprintf('\nComputing average protein expression per cluster per marker per file for %d files ... %5d',length(handles.all_fcs_filenames)+1,1);
marker_node_average=cell(0); counter = 1;
% get the average from the pooled data
load(fullfile(handles.directoryname, handles.cluster_mst_upsample_filename),'data','marker_names');
for j=1:length(marker_names)
    marker_node_average{counter,1} = 'POOLED';
    marker_node_average{counter,2} = marker_names{j};
    [group_avg, counts, group_idx_values] = SPADE_compute_one_marker_group_mean(data(j,:), idx);
    group_avg(group_idx_values==0)=[];
    counts(group_idx_values==0)=[];
    group_idx_values(group_idx_values==0)=[];
    tmp = zeros(1,max(idx))+NaN;
    tmp(group_idx_values) = group_avg;
    marker_node_average{counter,3} = tmp;
    counter = counter + 1;
end
marker_node_average{counter,1} = 'POOLED';
marker_node_average{counter,2} = 'CellFreq';
[dummy, tmp] = SPADE_compute_one_marker_group_mean(ones(1,length(idx)),idx);    
marker_node_average{counter,3} = tmp(:)';
counter = counter + 1;
% get the average from individual files
for i=1:length(handles.all_fcs_filenames)
    fprintf('\b\b\b\b\b%5d',i+1);
    load(fullfile(handles.directoryname, [handles.all_fcs_filenames{i}(1:end-3),'mat']),'data','marker_names');
    for j=1:length(marker_names)
        marker_node_average{counter,1} = handles.file_annot{i};
        marker_node_average{counter,2} = marker_names{j};
        [group_avg, counts, group_idx_values] = SPADE_compute_one_marker_group_mean(data(j,:), all_assign{i}); % the following few lines are for the purpose that: some file may not have any cell belong to one particular node, and therefore, the "group_avg" does not have information for every node
        group_avg(group_idx_values==0)=[];
        counts(group_idx_values==0)=[];
        group_idx_values(group_idx_values==0)=[];
        tmp = zeros(1,max(idx))+NaN;
        tmp(group_idx_values) = group_avg;
        marker_node_average{counter,3} = tmp;
        counter = counter + 1;
    end    
    marker_node_average{counter,1} = handles.file_annot{i};
    marker_node_average{counter,2} = 'CellFreq';
    [group_avg, counts, group_idx_values] = SPADE_compute_one_marker_group_mean(ones(1,length(handles.all_assign{i})),handles.all_assign{i}); 
    marker_node_average{counter,3} = zeros(1,max(idx));
    marker_node_average{counter,3}(group_idx_values)=counts;
    counter = counter + 1;
end
save(fullfile(handles.directoryname, handles.cluster_mst_upsample_filename), 'all_assign','all_fcs_filenames','file_annot', 'marker_node_average', '-append');
fprintf('\nDone\n\n')
guidata(hObject, handles);


% --- Executes on button press in button_4_mst_layout.
function button_4_mst_layout_Callback(hObject, eventdata, handles)

% --- Executes on button press in button_4_upsampling.
function button_4_upsampling_Callback(hObject, eventdata, handles)


% --- Executes on button press in button_one_click_for_all.
function button_one_click_for_all_Callback(hObject, eventdata, handles)
button_1_compute_local_density_Callback(handles.button_1_compute_local_density, [], handles)
button_2_pool_selected_files_Callback(handles.button_2_pool_selected_files, [], handles)
button_3_clustering_Callback(handles.button_3_clustering, [], handles)



% --- Executes on button press in button_View_Edit_SPADE_tree.
function button_View_Edit_SPADE_tree_Callback(hObject, eventdata, handles)
% check whether this button needs to do anything.
if length(handles.directoryname)==0 
    fprintf('No working directory is selected!!\n\n');
    return
end
if exist(handles.directoryname)~=7
    fprintf('The selected directory is somehow not a valid directory,\n maybe deleted by user while the SPADE GUI is running!\n\n');
    return
end
if length(handles.all_fcs_filenames)==0 
    fprintf('There are no fcs files in this directory!\n\n');
    return
end
if length(handles.all_fcs_filenames) ~= length(handles.file_annot)
    fprintf('Length of all_fcs_filenames and file_annot does not match!\nTerrible - this should not happen\n\n');
    return
end
% % check if the pooled downsampled data file exists
if exist(fullfile(handles.directoryname, handles.pooled_downsampled_filename))~=2
    fprintf('The pooled downsampled data does not exist!\nPlease click the "Pool selected files" button before running this step!\n\n');
    return
end
% % check if the clustering+mst+upsample result file exist or not
if exist(fullfile(handles.directoryname, handles.cluster_mst_upsample_filename))~=2
    fprintf('The result file does not exist!\nPlease click the "cluster+mst+upsample" button before running this function!\n\n');
    return
end
result_filename{1} = fullfile(handles.directoryname,handles.cluster_mst_upsample_filename);
View_Edit_SPADE_tree_annotation(result_filename);






% --- Executes on button press in pushbutton11.
function pushbutton11_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton11 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


